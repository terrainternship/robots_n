# pip install python-Levenshtein
# pip install fuzzywuzzy



# Преобразование числительных из текстовой записи в числовую для русского языка

from fuzzywuzzy import process, fuzz

number_words_base = {
    'ноль': 0,
    'один': 1,
    'два': 2,
    'три': 3,
    'четыре': 4,
    'пять': 5,
    'шесть': 6,
    'семь': 7,
    'восемь': 8,
    'девять': 9,
    'десять': 10,
    'одиннадцать': 11,
    'двенадцать': 12,
    'тринадцать': 13,
    'четырнадцать': 14,
    'пятнадцать': 15,
    'шестнадцать': 16,
    'семнадцать': 17,
    'восемнадцать': 18,
    'девятнадцать': 19,
    'двадцать': 20,
    'тридцать': 30,
    'сорок': 40,
    'пятьдесят': 50,
    'шестьдесят': 60,
    'семьдесят': 70,
    'восемьдесят': 80,
    'девяносто': 90,
    'сто': 100,
    'двести': 200,
    'триста': 300,
    'четыреста': 400,
    'пятьсот': 500,
    'шестьсот': 600,
    'семьсот': 700,
    'восемьсот': 800,
    'девятьсот': 900
}

# Второй словарь для масштабирующих чисел (1000, 1000000 и т.д.)
number_words_scale = {
    'тысяча': 1000,
    'миллион': 1000000
    # ... и так далее для больших чисел, если нужно ...
}
# Алгоритмы fuzzywuzzy необходимы для отбрасывания окончаний
# Функция для преобразования числительного в число с помощью fuzzy matching
# Функция преобразования слов в число с учетом различных масштабов
def word_to_number_fuzzy(russian_number):
    words = russian_number.split()
    number = 0
    current_number = 0

    # Итерация по каждому слову во входной строке
    for word in words:
        # Использование FuzzyWuzzy для поиска наиболее подходящего масштабирующего числа
        scale_match = process.extractOne(word, number_words_scale.keys(), scorer=fuzz.token_set_ratio)
        if scale_match and scale_match[1] > 80:
            if number == 0 and current_number == 0:
                # Если это первое слово и оно масштабирующее, добавляем его значение к number
                number += number_words_scale[scale_match[0]]
            else:
                # Умножаем текущее число на масштаб и добавляем к общему числу
                current_number *= number_words_scale[scale_match[0]]
                number += current_number
                current_number = 0
        else:
            # Использование FuzzyWuzzy для поиска наиболее подходящего основного числа
            base_match = process.extractOne(word, number_words_base.keys(), scorer=fuzz.token_set_ratio)
            if base_match and base_match[1] > 60:  # Используется 60%, потому что алгоритмы fuzzywuzzy исчитают количество совпадающих букв из общего числа, так для "два" и "две" совпадение только 66%
                # Добавляем значение основного числа к текущему числу
                current_number += number_words_base[base_match[0]]

    # Добавляем последнее текущее число к общему числу
    number += current_number

    return number

# Тестирование функции
test_numbers = [
    'одна тысяча двести тридцать четыре',
    'две тысячи пятьсот шестьдесят семь',
    'три тысячи четыреста восемьдесят восемь',
    'четыре тысячи девятьсот девяносто девять',
    'пять тысяч', 'шесть тысяч триста двенадцать',
    'семь тысяч двести двадцать один',
    'восемь тысяч четыреста три',
    'девять тысяч восемьсот семьдесят шесть',
    'миллион',
    'миллион одна тысяча',
    'миллион двести',
    'миллион триста тридцать три тысячи четыреста пятьдесят шесть',
    'два миллиона',
    'два миллиона пятьсот тысяч',
    'три миллиона четыреста тысяч',
    'четыре миллиона восемьсот тысяч',
    'пять миллионов девятьсот тысяч',
    'шесть миллионов семьсот тысяч',
    'семь миллионов одна тысяча двести тридцать четыре'
]

converted_numbers = [word_to_number_fuzzy(num) for num in test_numbers]
print(converted_numbers)